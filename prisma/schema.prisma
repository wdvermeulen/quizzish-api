// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  room          Room?
  games         Game[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Room {
  startCode String   @id
  hostIds   Host[]
  gameId    String   @unique
  game      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Host {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(128)
  peerId    String   @unique @db.VarChar(64)
  roomId    String
  userId    String
  room      Room     @relation(fields: [roomId], references: [startCode], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([roomId, name])
  @@unique([userId, id])
}

model Game {
  id                 String   @id @default(cuid())
  userId             String
  room               Room?
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type               GameType @default(CUSTOM)
  name               String?  @db.VarChar(64)
  description        String?  @db.VarChar(1024)
  rounds             Round[]
  timeLimitInMinutes Int      @default(1440)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@unique([userId, id])
}

model Round {
  id                 String   @id @default(cuid())
  name               String?  @db.VarChar(128)
  userId             String
  gameId             String
  game               Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  index              Int
  nextRoundId        String?
  nextRound          Round?   @relation("NextRound", fields: [nextRoundId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  previousRound      Round[]  @relation("NextRound")
  slides             Slide[]
  timeLimitInMinutes Int?
  description        String?  @db.VarChar(1024)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@unique([userId, id])
}

model Slide {
  id                           String                 @id @default(cuid())
  userId                       String
  index                        Int
  type                         SlideType              @default(NO_ANSWER)
  name                         String?                @db.VarChar(128)
  roundId                      String
  round                        Round                  @relation(fields: [roundId], references: [id], onDelete: Cascade)
  timeLimitInSeconds           Int?
  description                  String?                @db.VarChar(512)
  previousMultipleChoiceAnswer MultipleChoiceOption[] @relation("NextSlide")
  previousCorrectAnswer        Slide[]                @relation("NextCorrectSlide")
  previousIncorrectAnswer      Slide[]                @relation("NextIncorrectSlide")
  multipleChoiceOptions        MultipleChoiceOption[]
  closestToValue               BigInt?
  statementIsTrue              Boolean?
  checkMethod                  CheckMethod            @default(INSTANT)
  voters                       Voters                 @default(ALL_PARTICIPANTS)
  earlyCorrectPoints           Int                    @default(10)
  lateCorrectPoints            Int                    @default(0)
  earlyIncorrectPoints         Int                    @default(0)
  lateIncorrectPoints          Int                    @default(0)
  pointMethod                  PointMethod            @default(NONE)
  correctNextSlideId           String?
  correctNextSlide             Slide?                 @relation("NextCorrectSlide", fields: [correctNextSlideId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  incorrectNextSlideId         String?
  incorrectNextSlide           Slide?                 @relation("NextIncorrectSlide", fields: [incorrectNextSlideId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  explanation                  String?                @db.VarChar(512)
  largeText                    String?                @db.Text
  media                        String?                @db.VarChar(128)
  images                       Image[]
  createdAt                    DateTime               @default(now())
  updatedAt                    DateTime               @updatedAt

  @@unique([userId, id])
}

model MultipleChoiceOption {
  id          String  @id @default(cuid())
  index       Int     @unique
  userId      String
  slideId     String
  slide       Slide   @relation(fields: [slideId], references: [id], onDelete: Cascade)
  isRegex     Boolean @default(false)
  nextSlideId String?
  nextSlide   Slide?  @relation("NextSlide", fields: [nextSlideId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  description String? @db.VarChar(512)
  earlyPoints Int?    @default(10)
  latePoints  Int?    @default(0)

  @@unique([userId, id])
}

model Image {
  id      String @id @default(cuid())
  index   Int
  userId  String
  slideId String
  slide   Slide  @relation(fields: [slideId], references: [id], onDelete: Cascade)
  image   String @db.VarChar(128)

  @@unique([userId, id])
}

enum GameType {
  REGULAR_QUIZ
  PUBQUIZ
  ESCAPE_ROOM
  CUSTOM
}

enum SlideType {
  NO_ANSWER
  MULTIPLE_CHOICE
  TRUE_FALSE
  OPEN
  MULTIPLE_SELECT
  CLOSEST_TO
  SORT
  CATEGORIZE
  PAIR
  POLL
}

enum CheckMethod {
  MANUAL
  INSTANT
  VOTE
  POLL
  MOST_ANSWERED
  NONE
}

enum PointMethod {
  TIME
  ORDER
  NONE
}

enum Voters {
  HOSTS
  SELECTED_PARTICIPANT
  RANDOM_PARTICIPANT
  ALL_PARTICIPANTS
  GUESTS
}

enum VoteType {
  SINGLE_VOTE // Each player, host, or participant casts a single vote for their preferred answer. This is a simple and straightforward method where each voter can choose only one option.
  MULTIPLE_VOTES // Each voter can cast multiple votes, either for multiple answers or multiple times for the same answer. This allows participants to express their preferences for multiple options to different answers.
  RANKED_VOTING
  INSTANT_RUNOFF_VOTING // Also known as ranked choice voting, this method allows participants to rank the answers in order of preference. The answer with the most first-place votes wins, but if no answer receives a majority, the lowest-ranked answer is eliminated, and its votes are redistributed to the remaining answers. This process continues until a single answer receives a majority of votes.
  WEIGHTED_VOTING // Each voter is assigned a certain number of points or weight, and they can distribute these points among the answers based on their preferences. This allows participants to allocate their votes in a more flexible manner, assigning more points to their preferred answer and fewer points to other answers.
}
